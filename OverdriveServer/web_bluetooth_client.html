<!DOCTYPE html>
<html>

<head>
    <title>OVERDRIVE COMMAND</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=Roboto:wght@300;400;500&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --neon-blue: #00f0ff;
            --neon-orange: #ffa600;
            --neon-red: #ff2a2a;
            --neon-green: #00ff41;
            --bg-dark: #0e0e14;
            --panel-bg: rgba(20, 20, 28, 0.95);
            --border-color: #333;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background-color: var(--bg-dark);
            color: #eee;
            margin: 0;
            padding: 20px;
            overflow-x: hidden;
            background-image:
                radial-gradient(circle at 50% 50%, rgba(0, 80, 255, 0.05) 0%, transparent 60%),
                linear-gradient(rgba(0, 240, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 240, 255, 0.03) 1px, transparent 1px);
            background-size: 100% 100%, 30px 30px, 30px 30px;
        }

        h1,
        h2,
        h3 {
            font-family: 'Orbitron', sans-serif;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin: 0;
            text-shadow: 0 0 10px rgba(0, 240, 255, 0.5);
        }

        h1 {
            color: var(--neon-blue);
            font-size: 2.5em;
            margin-bottom: 5px;
        }

        .subtitle {
            color: #888;
            margin-bottom: 30px;
            font-size: 0.9em;
            letter-spacing: 1px;
        }

        .scan-container {
            text-align: center;
            margin-bottom: 40px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-bottom: 1px solid #333;
        }

        /* Lobby / Overlay */
        #lobby-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
        }

        .mode-card {
            background: var(--panel-bg);
            border: 2px solid #555;
            padding: 20px;
            margin: 10px;
            width: 300px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .mode-card:hover {
            border-color: var(--neon-orange);
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 166, 0, 0.3);
        }

        .mode-card.selected {
            border-color: var(--neon-blue);
            background: rgba(0, 240, 255, 0.1);
            box-shadow: 0 0 20px rgba(0, 240, 255, 0.3);
        }

        button {
            background: rgba(0, 240, 255, 0.1);
            border: 1px solid var(--neon-blue);
            color: var(--neon-blue);
            padding: 10px 30px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.2s;
            clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
            margin: 0 10px;
            text-transform: uppercase;
        }

        button.active {
            background: var(--neon-blue);
            color: #000;
            box-shadow: 0 0 20px rgba(0, 240, 255, 0.4);
        }

        button:hover {
            background: var(--neon-blue);
            color: #000;
            box-shadow: 0 0 20px rgba(0, 240, 255, 0.4);
        }

        .btn-disconnect {
            border-color: var(--neon-red);
            color: var(--neon-red);
            background: rgba(255, 42, 42, 0.1);
            padding: 5px 10px;
            font-size: 0.7em;
        }

        .btn-disconnect:hover {
            background: var(--neon-red);
            color: #fff;
            box-shadow: 0 0 15px rgba(255, 42, 42, 0.4);
        }

        /* --- Game HUD & Car Panels --- */

        #game-area {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }

        .car-panel {
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            padding: 0;
            position: relative;
            backdrop-filter: blur(5px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            transition: transform 0.2s;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .car-panel.dead {
            filter: grayscale(100%) brightness(0.5);
            border-color: #333;
        }

        .car-panel.winner {
            border-color: var(--neon-orange);
            box-shadow: 0 0 30px var(--neon-orange);
        }

        .car-header {
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #333;
        }

        .car-name {
            color: var(--neon-orange);
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2em;
            font-weight: bold;
        }

        .car-status-row {
            display: flex;
            gap: 10px;
            padding: 15px;
        }

        .stat-bar-container {
            flex: 1;
        }

        .stat-label {
            font-size: 0.7em;
            color: #888;
            margin-bottom: 3px;
            text-transform: uppercase;
            font-family: 'Orbitron';
        }

        .bar-outer {
            height: 10px;
            background: #222;
            border: 1px solid #444;
            width: 100%;
            position: relative;
        }

        .bar-inner {
            height: 100%;
            width: 100%;
            transition: width 0.2s ease-out;
        }

        .hp-bar {
            background: var(--neon-green);
            box-shadow: 0 0 5px var(--neon-green);
        }

        .energy-bar {
            background: var(--neon-blue);
            box-shadow: 0 0 5px var(--neon-blue);
        }

        .controls-layer {
            padding: 15px;
            background: rgba(255, 255, 255, 0.02);
            border-top: 1px solid #333;
        }

        /* Weapon Buttons */
        .weapon-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }

        .weapon-btn {
            background: rgba(255, 0, 0, 0.1);
            border: 1px solid var(--neon-red);
            color: var(--neon-red);
            font-size: 0.9em;
            padding: 15px 5px;
            text-align: center;
            clip-path: none;
            /* Override standard button */
            border-radius: 4px;
        }

        .weapon-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
            border-color: #555;
            color: #555;
            background: #222;
            box-shadow: none;
        }

        .weapon-btn:not(:disabled):hover {
            background: var(--neon-red);
            color: #fff;
            box-shadow: 0 0 15px var(--neon-red);
        }

        .weapon-btn.utility {
            border-color: var(--neon-blue);
            color: var(--neon-blue);
            background: rgba(0, 240, 255, 0.1);
        }

        .weapon-btn.utility:not(:disabled):hover {
            background: var(--neon-blue);
            color: #000;
            box-shadow: 0 0 15px var(--neon-blue);
        }

        /* Sci-Fi Slider */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
            margin: 10px 0;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 15px;
            width: 15px;
            background: var(--neon-orange);
            cursor: pointer;
            margin-top: -6px;
            transform: rotate(45deg);
            box-shadow: 0 0 5px var(--neon-orange);
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 3px;
            cursor: pointer;
            background: #444;
        }

        .score-display {
            font-size: 1.5em;
            color: #fff;
            font-family: 'Orbitron';
            text-align: center;
            margin-top: 10px;
        }

        /* Map & track log UI */
        #ui-lower {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 400px;
            max-width: calc(100vw - 40px);
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
            z-index: 50;
        }

        #ui-lower>* {
            pointer-events: auto;
        }

        #track-log {
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid #333;
            height: 150px;
            overflow-y: auto;
            padding: 10px;
            font-family: monospace;
            font-size: 0.8em;
            color: #888;
            border-radius: 4px;
        }

        .log-entry {
            margin-bottom: 2px;
        }

        .log-entry.info {
            color: #0af;
        }

        .log-entry.hit {
            color: #f22;
            font-weight: bold;
        }

        .log-entry.win {
            color: var(--neon-orange);
            font-size: 1.2em;
            font-weight: bold;
            border: 1px solid var(--neon-orange);
            padding: 5px;
            text-align: center;
        }

        /* Map specific styling */
        #map-container {
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid var(--neon-blue);
            border-radius: 4px;
            padding: 10px;
        }

        /* Leaderboard */
        #leaderboard {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 300px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid var(--neon-blue);
            padding: 0;
            z-index: 100;
            transition: opacity 0.3s, transform 0.3s;
        }

        #leaderboard.hidden {
            opacity: 0;
            transform: translateY(-20px);
            pointer-events: none;
        }

        .lb-header {
            background: var(--neon-blue);
            color: #000;
            font-family: 'Orbitron';
            font-weight: bold;
            padding: 8px 10px;
            text-align: center;
        }

        .lb-row {
            display: flex;
            justify-content: space-between;
            padding: 10px 15px;
            border-bottom: 1px solid #333;
            font-family: 'Orbitron';
            color: #fff;
        }

        .lb-rank {
            width: 30px;
            color: #888;
        }

        .lb-name {
            flex: 1;
            text-align: left;
        }

        .lb-score {
            color: var(--neon-orange);
            font-weight: bold;
        }
    </style>
</head>

<body>

    <!-- Leaderboard Overlay -->
    <div id="leaderboard" class="hidden">
        <div class="lb-header">LEADERBOARD</div>
        <div id="lb-content">
            <!-- content -->
        </div>
    </div>

    <!-- Lobby UI -->
    <div id="lobby-overlay" style="display:none;">
        <h1 style="font-size:3em;">SELECT GAME MODE</h1>
        <div style="display:flex;">
            <div class="mode-card selected" onclick="selectMode('BATTLE')">
                <h2>BATTLE</h2>
                <p>15 TAKEDOWNS<br>Disable opponents to score!</p>
            </div>
            <div class="mode-card" onclick="selectMode('RACE')">
                <h2>RACE</h2>
                <p>20 LAPS<br>First to cross the line wins!</p>
            </div>
        </div>
        <button onclick="startGame()" style="margin-top:30px; font-size:1.5em; padding:20px 60px;">START ENGINE</button>
        <button onclick="closeLobby()" style="margin-top:10px; border-color:#555; color:#555;">CANCEL</button>
    </div>

    <div style="max-width: 1400px; margin: 0 auto;">
        <!-- Header -->
        <div style="display:flex; justify-content:space-between; align-items:center;">
            <div>
                <h1>OVERDRIVE <span style="font-weight:900; color:#fff;">ENGINE</span></h1>
                <div class="subtitle">Mk II RESTORATION PROJECT</div>
            </div>

            <div style="text-align:right;">
                <div id="game-status" style="color:var(--neon-orange); font-family:'Orbitron'; font-size:1.2em;">STANDBY
                </div>
                <div style="font-size:0.8em; color:#444;">GAME TICK: <span id="tick-counter">0</span></div>
            </div>
        </div>

        <!-- Toolbar -->
        <div class="scan-container">
            <button id="btn-scan">ADD CAR</button>
            <button id="btn-scan-track" style="border-color: var(--neon-orange); color: var(--neon-orange);">TRACK
                SCAN</button>
            <span style="border-left:1px solid #444; margin:0 10px;"></span>
            <button id="btn-lobby" class="active">GAME SETUP</button>
            <label style="margin-left:20px; font-size:0.8em; color:#666;">
                <input type="checkbox" id="cb-global-v4"> FORCE V4 MODE
            </label>
        </div>

        <!-- Main Game Board -->
        <div id="game-area"></div>

        <!-- Logs & Maps -->
        <div id="ui-lower">
            <div id="track-log">
                <div class="log-entry info">System Initialized. Ready to connect units.</div>
            </div>
        </div>
    </div>

    <script>
        // --- CONSTANTS ---
        const SERVICE_UUID = "be15beef-6186-407e-8381-0bd89c4d8df4";
        const CHAR_READ_UUID = "be15bee0-6186-407e-8381-0bd89c4d8df4";
        const CHAR_WRITE_UUID = "be15bee1-6186-407e-8381-0bd89c4d8df4";

        const CMD_SDK_MODE = 0x90;
        const CMD_SET_SPEED = 0x24;
        const CMD_CHANGE_LANE = 0x25;
        const CMD_LIGHTS = 0x33;

        const TRACK_PIECES = {
            10: "CROSS", 17: "CURVE", 18: "CURVE", 20: "CURVE", 23: "CURVE", 24: "CURVE", 27: "CURVE",
            33: "FINISH", 34: "START",
            36: "STRAIGHT", 39: "STRAIGHT", 40: "STRAIGHT", 48: "STRAIGHT", 51: "STRAIGHT",
            43: "JUMP", 58: "JUMP", 46: "LAND", 63: "LAND",
            53: "SPECIAL", 54: "SPECIAL", 57: "SPECIAL"
        };

        // --- GLOBALS ---
        const cars = []; // Array of Car objects
        const remoteCars = {}; // Map of remote players

        let socket = null;
        let gameLoopId = null;
        let tickCount = 0;
        let isScanningTrack = false;
        let trackMap = []; // Array of {id, name, type, clockwise}
        let trackScanStartId = null; // Track the starting piece ID
        let trackScanComplete = false; // Track if we've completed the loop
        let pendingPiece = null;
        let currentMode = 'BATTLE'; // 'BATTLE' or 'RACE'
        let gameActive = false;
        let winScore = 15; // Takedowns or Laps

        function log(msg, type = 'info') {
            const el = document.getElementById('track-log');
            const date = new Date().toLocaleTimeString();
            el.innerHTML += `<div class="log-entry ${type}">[${date}] ${msg}</div>`;
            el.scrollTop = el.scrollHeight;
        }

        // --- WEBSOCKET ---
        function connectSocket() {
            const host = window.location.hostname;
            // Connect to WS on port 7118
            socket = new WebSocket(`ws://${host}:7118`);
            socket.onopen = () => log("Multiplayer Link Established", "info");
            socket.onmessage = (event) => {
                try {
                    const msg = JSON.parse(event.data);
                    if (msg.eventType === "client_update_bc") {
                        // Payload: { id, name, score, laps, hp, pieceId, color }
                        const data = msg.payload;
                        // Ignore our own cars
                        if (cars.some(c => c.id === data.id)) return;

                        remoteCars[data.id] = data;
                        updateLeaderboard();
                        // Trigger map redraw if map exists
                        if (mapCanvas) drawMap(trackMap, 0);
                    } else if (msg.eventType === "track_data") {
                        // Payload: Segment[] { type, internalID, flipped, ... }
                        const serverTrack = JSON.parse(msg.payload);
                        trackMap = serverTrack.map(s => ({
                            id: s.internalID,
                            name: TRACK_PIECES[s.internalID] || "UNKNOWN",
                            type: (s.type === 2 ? 'CURVE' : (s.type === 4 || s.type === 3 ? 'FINISH' : 'STRAIGHT')),
                            clockwise: s.flipped
                        }));
                        log("Received Map Data from Server", "info");
                        drawMap(trackMap, 0);
                    }
                } catch (e) { console.error(e); }
            };
        }
        connectSocket();

        function broadcastUpdate(car) {
            if (!socket || socket.readyState !== WebSocket.OPEN) return;
            const data = {
                id: car.id,
                name: car.name,
                score: car.score,
                laps: car.laps,
                hp: car.hp,
                pieceId: car.currentPieceId,
                color: car.profile.color
            };
            socket.send(JSON.stringify({ eventType: "client_update", payload: data }));
        }

        // --- LOBBY LOGIC ---
        function openLobby() {
            const lb = document.getElementById('leaderboard');
            const status = document.getElementById('game-status');

            if (gameActive) {
                // End current game
                gameActive = false;
                status.innerText = "LOBBY";
                if (lb) lb.classList.add('hidden');
                cars.forEach(c => c.setSpeed(0));
                return;
            }

            const mode = prompt("Race Type:\n1 = Battle (15 Kills)\n2 = Race (3 Laps)");
            if (!mode) return;

            if (mode === '1') {
                currentMode = 'BATTLE';
                winScore = 15;
                status.innerText = "BATTLE ROYALE - 15 KILLS";
            } else {
                currentMode = 'RACE';
                winScore = 3;
                status.innerText = "RACE - 3 LAPS";
            }

            // Reset all cars
            cars.forEach(c => {
                c.score = 0;
                c.laps = 0;
                c.hp = c.maxHp;
                c.energy = c.maxEnergy;
                c.dead = false;
                c.div.classList.remove('dead', 'winner');
                c.updateUI();
            });

            gameActive = true;
            if (lb) lb.classList.remove('hidden'); // Show leaderboard
            updateLeaderboard();
            log("Game Started!", "win");
        }

        // --- UI UPDATERS ---
        function updateLeaderboard() {
            const list = [];
            // Add Locale
            cars.forEach(c => list.push({ name: c.name, score: (currentMode == 'RACE' ? c.laps : c.score), color: c.profile.color }));
            // Add Remote
            for (let id in remoteCars) {
                const rc = remoteCars[id];
                list.push({ name: rc.name, score: (currentMode == 'RACE' ? rc.laps : rc.score), color: rc.color });
            }

            // Sort Descending
            list.sort((a, b) => b.score - a.score);

            const div = document.getElementById('lb-content');
            div.innerHTML = '';
            list.forEach((p, i) => {
                div.innerHTML += `
                    <div class="lb-row">
                        <span class="lb-rank">${i + 1}</span>
                        <span class="lb-name" style="color:${p.color}">${p.name}</span>
                        <span class="lb-score">${p.score}</span>
                    </div>
                `;
            });
            document.getElementById('leaderboard').style.display = 'block';
        }

        // --- GAME ENGINE ---
        class GameEngine {
            constructor() {
                this.running = false;
            }

            start() {
                if (this.running) return;
                this.running = true;
                this.loop();
                log("Game Engine Started", "info");
            }

            stop() {
                this.running = false;
                cancelAnimationFrame(gameLoopId);
            }

            loop() {
                if (!this.running) return;
                tickCount++;
                document.getElementById('tick-counter').innerText = tickCount;

                // Update all cars
                cars.forEach(car => {
                    car.update(1 / 60);
                    // Broadcast periodically (every 10 ticks = 6 times/sec)
                    if (tickCount % 10 === 0) broadcastUpdate(car);
                });

                gameLoopId = requestAnimationFrame(this.loop.bind(this));
            }
        }

        const engine = new GameEngine();

        // --- CAR CLASS ---
        class Car {
            constructor(device) {
                this.device = device;
                this.server = null;
                this.writeChar = null;
                this.id = device.id;
                this.name = device.name || "Unknown Unit";

                // Game Stats
                this.maxHp = 100;
                this.hp = 100;
                this.maxEnergy = 100;
                this.energy = 100;
                this.dead = false;
                this.score = 0;

                // Physics/State
                this.laps = 0;
                this.lastPieceId = 0;
                this.currentPieceId = 0;
                this.currentPieceName = "UNKNOWN";
                this.laneOffset = 0.0;
                this.targetSpeed = 0;

                this.v4mode = document.getElementById('cb-global-v4').checked;
                this.div = null;
                this.pingInterval = null;

                this.profile = this.getProfile(this.name);
            }

            getProfile(name) {
                const DB = {
                    "Skull": { primary: "PLASMA CANNON", ability: "SLOW SHOT", primaryCost: 25, abilityCost: 40, color: "#ff0000" },
                    "GroundShock": { primary: "LIGHTNING", ability: "CHARGE", primaryCost: 20, abilityCost: 35, color: "#0055ff" },
                    "Thermo": { primary: "FLAMETHROWER", ability: "RADIATE", primaryCost: 15, abilityCost: 30, color: "#ff5500" },
                    "Nuke": { primary: "DECIMATOR", ability: "SHIELD", primaryCost: 60, abilityCost: 25, color: "#00ff00" },
                    "Guardian": { primary: "SONIC BEAM", ability: "SCRAMBLE", primaryCost: 15, abilityCost: 50, color: "#00ffff" },
                    "Big Bang": { primary: "POWER STOMP", ability: "RESTORE", primaryCost: 30, abilityCost: 50, color: "#55aa00" }
                };
                for (let k in DB) { if (name.includes(k)) return DB[k]; }
                return { primary: "PRIMARY FIRE", ability: "TURBO BOOST", primaryCost: 20, abilityCost: 40, color: "#aaaaaa" };
            }

            startPing() {
                if (this.pingInterval) clearInterval(this.pingInterval);
                this.pingInterval = setInterval(async () => {
                    if (!this.dead && this.server && this.server.connected) {
                        try { await this.write(new Uint8Array([2, 22])); } catch (e) { }
                    }
                }, 2000);
            }

            async connect() {
                try {
                    this.server = await this.device.gatt.connect();
                    const service = await this.server.getPrimaryService(SERVICE_UUID);
                    this.writeChar = await service.getCharacteristic(CHAR_WRITE_UUID);

                    const readChar = await service.getCharacteristic(CHAR_READ_UUID);
                    await readChar.startNotifications();
                    readChar.addEventListener('characteristicvaluechanged', this.handleMsg.bind(this));

                    await this.enableSdkMode();
                    await this.write(new Uint8Array([0x01, 0x1A])); // Request Battery

                    this.startPing();
                    this.createUI();
                    log(`Connected to ${this.name}`, "info");
                    updateLeaderboard();

                } catch (e) {
                    log(`Connection Init Failed: ${e}`, "hit");
                    console.error(e);
                }
            }

            update(dt) {
                if (this.dead) return;
                if (this.energy < this.maxEnergy) {
                    this.energy += 5 * dt;
                    this.updateUI();
                }
                if (this.hp < this.maxHp && this.hp > 0) {
                    this.hp += 0.5 * dt;
                    this.updateUI();
                }
            }

            shootPrimary() {
                if (this.dead || this.energy < 20) return;
                this.energy -= 20;
                log(`${this.name} fired ${this.profile.primary}!`, "hit");
                this.updateUI();

                // Find closest car ahead within shooting range
                let closestTarget = null;
                let minDistance = Infinity;

                cars.forEach(target => {
                    if (target !== this && !target.dead && target.currentPieceId !== 0) {
                        // Calculate if target is ahead
                        const myPosition = this.currentPieceId + (this.laps * 100);
                        const targetPosition = target.currentPieceId + (target.laps * 100);
                        const distance = targetPosition - myPosition;

                        // Target must be ahead (positive distance) within 3 pieces
                        if (distance > 0 && distance <= 3 && distance < minDistance) {
                            closestTarget = target;
                            minDistance = distance;
                        }
                    }
                });

                if (closestTarget) {
                    log(`>> TARGET ACQUIRED: ${closestTarget.name} (distance: ${minDistance})`, "info");
                    closestTarget.takeDamage(15, this);
                }
            }

            activateAbility() {
                if (this.dead || this.energy < 40) return;
                this.energy -= 40;
                log(`${this.name} ACTIVATED BOOST!`, "info");
                this.flashLights(2, 3, 0, 150, 10);
                const oldSpeed = this.targetSpeed;
                this.setSpeed(1000);
                setTimeout(() => this.setSpeed(oldSpeed), 1500);
                this.updateUI();
            }

            takeDamage(amount, attacker = null) {
                if (this.dead) return;
                this.hp -= amount;
                log(`${this.name} took ${amount} damage!`, "hit");
                this.flashLights(0, 3, 0, 150, 10);

                if (this.hp <= 0) {
                    this.hp = 0;
                    if (attacker) {
                        attacker.score++;
                        attacker.updateUI();
                        updateLeaderboard(); // Rank change!
                        log(`${attacker.name} Scored a Takedown!`, "info");
                        if (gameActive && currentMode === 'BATTLE' && attacker.score >= winScore) winGame(attacker);
                    }
                    this.die();
                }
                this.updateUI();
            }

            die() {
                this.dead = true;
                log(`${this.name} WASTED!`, "hit");
                this.setSpeed(0);
                this.setLane(this.laneOffset > 0 ? -60 : 60);
                if (this.div) this.div.classList.add('dead');
                setTimeout(() => this.respawn(), 3000);
            }

            respawn() {
                this.dead = false;
                this.hp = this.maxHp;
                if (this.div) this.div.classList.remove('dead');
                log(`${this.name} Respawned!`, "info");
                this.updateUI();
                if (gameActive) this.setSpeed(400);
            }

            async write(data) { if (this.writeChar) await this.writeChar.writeValue(data); }
            async enableSdkMode() { await this.write(new Uint8Array([0x03, CMD_SDK_MODE, 0x01, 0x01])); }

            async setSpeed(speed) {
                const size = this.v4mode ? 8 : 7;
                const buffer = new ArrayBuffer(size + 1);
                const view = new DataView(buffer);
                view.setUint8(0, this.v4mode ? 7 : 6); // Length
                view.setUint8(1, CMD_SET_SPEED);
                view.setInt16(2, speed, true);
                view.setInt16(4, 1000, true); // Accel
                view.setUint8(6, 0x01); // Flags
                if (this.v4mode) view.setUint8(7, 0x01);
                await this.write(new Uint8Array(view.buffer));
                this.targetSpeed = speed;
            }

            async setLane(offset) {
                const view = new DataView(new ArrayBuffer(12));
                view.setUint8(0, 0x0B);
                view.setUint8(1, CMD_CHANGE_LANE);
                view.setInt16(2, 250, true);
                view.setInt16(4, 1000, true);
                view.setFloat32(6, offset, true);
                view.setUint8(10, 0x00);
                view.setUint8(11, 0x00);
                await this.write(new Uint8Array(view.buffer));
            }

            async flashLights(channel, effect, start, end, cycles) {
                const buffer = new ArrayBuffer(2 + 5);
                const view = new DataView(buffer);
                view.setUint8(0, 7);
                view.setUint8(1, 0x33);
                view.setUint8(2, 1);
                view.setUint8(3, channel);
                view.setUint8(4, effect);
                view.setUint8(5, start);
                view.setUint8(6, end);
                view.setUint8(7, cycles);
                await this.write(new Uint8Array(buffer));
            }

            handleMsg(event) {
                const val = event.target.value;
                const cmd = val.getUint8(1);

                if (cmd === 0x27) { // POSITION_UPDATE
                    if (val.byteLength > 3) {
                        const trackId = val.getUint8(3);
                        // Lap counting logic
                        if (trackId === 33 || trackId === 34) {
                            if (this.currentPieceId !== 33 && this.currentPieceId !== 34) {
                                this.laps++;
                                log(`${this.name} Completed Lap ${this.laps}!`, "info");
                                updateLeaderboard();
                                if (gameActive && currentMode === 'RACE' && this.laps >= winScore) winGame(this);
                            }
                        }

                        this.currentPieceId = trackId;
                        this.currentPieceName = TRACK_PIECES[trackId] || "UNK";

                        // Simple track scanning: just record pieces as we see them
                        if (isScanningTrack && trackId !== 0) {
                            const pieceName = TRACK_PIECES[trackId] || "UNKNOWN";
                            onTrackPieceDetected(trackId, pieceName);
                        }

                        if (!isScanningTrack && mapCanvas) drawMap(trackMap, this.currentPieceId);
                        this.updateUI();
                    }
                    if (val.byteLength > 7) {
                        this.laneOffset = val.getFloat32(4, true).toFixed(1);
                    }
                }
                else if (cmd === 0x29) { // TRANSITION_UPDATE
                    // Use transition to detect curve direction during scanning
                    if (isScanningTrack && trackMap.length > 0) {
                        const lastPiece = trackMap[trackMap.length - 1];
                        if (lastPiece && lastPiece.type === 'CURVE') {
                            const left = val.getUint8(16);
                            const right = val.getUint8(17);
                            lastPiece.clockwise = (left > right);
                        }
                    }
                }
            }

            createUI() {
                const container = document.getElementById('game-area');
                this.div = document.createElement('div');
                this.div.className = 'car-panel';
                this.div.innerHTML = `
                    <div class="car-header">
                        <div style="flex:1; display:flex; align-items:center; gap:8px;">
                            <span style="color:${this.profile.color}; font-size:1.3em;">â– </span>
                            <input type="text" class="car-name-input" value="${this.name}" 
                                   style="background:transparent; border:none; border-bottom:1px solid #444; color:#fff; font-family:'Orbitron'; font-size:0.9em; padding:2px 5px; width:150px;" 
                                   placeholder="Enter name...">
                        </div>
                        <div style="display:flex; gap:5px;">
                            <button class="btn-identify" style="padding:4px 12px; font-size:0.75em; background:linear-gradient(135deg, #00f0ff, #0080ff); color:#000; font-weight:bold; border:none;">PING</button>
                            <button class="btn-disconnect">X</button>
                        </div>
                    </div>
                    <div class="score-display">0</div>
                    <div class="car-status-row">
                        <div class="stat-bar-container">
                            <div class="stat-label">HULL INTEGRITY</div>
                            <div class="bar-outer"><div class="bar-inner hp-bar" style="width:100%"></div></div>
                            <div class="stat-label" style="margin-top:5px;">ENERGY CORE</div>
                            <div class="bar-outer"><div class="bar-inner energy-bar" style="width:100%"></div></div>
                        </div>
                    </div>
                    <div style="padding: 0 15px; font-size:0.8em; color:#aaa; font-family:monospace;">
                        LOC: <span class="val-loc">---</span> | OFF: <span class="val-off">0.0</span> | LAPS: <span class="val-laps">0</span>
                    </div>
                    <div class="controls-layer">
                        <div style="display:flex; justify-content:space-between; color:#888; font-size:0.8em;">
                             <span>THROTTLE</span> <span>LANE</span>
                        </div>
                        <div style="display:flex; gap:10px;">
                             <input type="range" class="speed-slider" min="0" max="1000" step="50" value="0">
                             <input type="range" class="lane-slider" min="-68" max="68" step="1" value="0">
                        </div>
                        <div class="weapon-grid">
                            <button class="weapon-btn btn-shoot">${this.profile.primary} (${this.profile.primaryCost})</button>
                            <button class="weapon-btn utility btn-ability">${this.profile.ability} (${this.profile.abilityCost})</button>
                        </div>
                         <button class="weapon-btn" style="width:100%; margin-top:5px; border-color:#fff; color:#fff;" onclick="this.getRootNode().host.takeDamage(25)">DEBUG: SELF DAMAGE 25</button>
                    </div>
                `;

                this.div.querySelector('.btn-disconnect').onclick = () => {
                    this.device.gatt.disconnect();
                    this.div.remove();
                    const idx = cars.indexOf(this);
                    if (idx > -1) cars.splice(idx, 1);
                    updateLeaderboard();
                };

                this.div.querySelector('.btn-identify').onclick = () => {
                    log(`ðŸ”¦ Pinging ${this.name}...`, "info");
                    this.flashLights(2, 3, 0, 255, 30);
                };

                const nameInput = this.div.querySelector('.car-name-input');
                nameInput.oninput = (e) => {
                    this.name = e.target.value || this.device.name;
                    updateLeaderboard();
                };
                nameInput.onblur = (e) => {
                    if (!e.target.value.trim()) {
                        e.target.value = this.device.name;
                        this.name = this.device.name;
                    }
                };

                const speedSl = this.div.querySelector('.speed-slider');
                speedSl.oninput = (e) => this.setSpeed(parseInt(e.target.value));
                const laneSl = this.div.querySelector('.lane-slider');
                laneSl.onchange = (e) => this.setLane(parseFloat(e.target.value));

                this.div.querySelector('.btn-shoot').onclick = () => this.shootPrimary();
                this.div.querySelector('.btn-ability').onclick = () => this.activateAbility();
                this.div.lastElementChild.querySelector('button').onclick = () => this.takeDamage(25);

                this.div.host = this;
                container.appendChild(this.div);
                this.updateUI();
            }

            updateUI() {
                if (!this.div) return;
                const hpPct = Math.max(0, (this.hp / this.maxHp) * 100);
                const enPct = Math.max(0, (this.energy / this.maxEnergy) * 100);

                this.div.querySelector('.hp-bar').style.width = hpPct + "%";
                this.div.querySelector('.energy-bar').style.width = enPct + "%";
                this.div.querySelector('.val-loc').innerText = this.currentPieceName + " (" + this.currentPieceId + ")";
                this.div.querySelector('.val-off').innerText = this.laneOffset;
                this.div.querySelector('.val-laps').innerText = this.laps;

                if (currentMode === 'BATTLE') this.div.querySelector('.score-display').innerText = this.score + " KILLS";
                else this.div.querySelector('.score-display').innerText = "LAP " + this.laps;

                this.div.querySelector('.btn-shoot').disabled = (this.energy < this.profile.primaryCost);
                this.div.querySelector('.btn-ability').disabled = (this.energy < this.profile.abilityCost);
            }
        }

        function winGame(winner) {
            gameActive = false;
            log(`*** WINNER: ${winner.name} ***`, "win");
            cars.forEach(c => {
                c.setSpeed(0);
                if (c === winner) {
                    c.div.classList.add('winner');
                    c.flashLights(2, 3, 0, 100, 20);
                } else {
                    c.flashLights(0, 0, 0, 0, 0);
                }
            });
            document.getElementById('game-status').innerText = "MATCH COMPLETE";

            // Hide leaderboard after 5 seconds
            setTimeout(() => {
                const lb = document.getElementById('leaderboard');
                if (lb) lb.classList.add('hidden');
            }, 5000);
        }

        // --- UI HANDLERS ---
        document.getElementById('btn-lobby').onclick = openLobby;

        document.getElementById('btn-scan').onclick = async () => {
            try {
                const device = await navigator.bluetooth.requestDevice({
                    filters: [{ services: [SERVICE_UUID] }],
                    optionalServices: [SERVICE_UUID]
                });
                const car = new Car(device);
                await car.connect();
                cars.push(car);
                if (!engine.running) engine.start();
            } catch (e) { if (e.name !== 'NotFoundError') console.error(e); }
        };

        document.getElementById('cb-global-v4').onchange = (e) => {
            cars.forEach(car => car.v4mode = e.target.checked);
        };

        // Track Scanner & Visualizer
        const btnTrackScan = document.getElementById('btn-scan-track');
        btnTrackScan.onclick = async () => {
            if (cars.length === 0) return alert("Add a car first!");
            const car = cars[0];

            if (isScanningTrack) {
                isScanningTrack = false;
                trackScanComplete = false;
                btnTrackScan.classList.remove('active');
                await car.setSpeed(0);
                log("Track Scan ENDED.", "info");
            } else {
                isScanningTrack = true;
                trackScanComplete = false;
                trackScanStartId = null;
                btnTrackScan.classList.add('active');
                trackMap = [];
                log("Track Scan STARTED. Driving...", "info");
                await car.setSpeed(300);
            }
        };

        let mapCanvas = null;

        function onTrackPieceDetected(id, name) {
            // Skip piece ID 0 (fallback/unknown)
            if (id === 0) return;

            // Normalize start/finish piece IDs (33 and 34 are the same physical piece)
            if (id === 34) id = 33; // Treat pre-finish (34) as finish (33)

            // Prevent consecutive duplicates
            const last = trackMap[trackMap.length - 1];
            if (last && last.id === id) return;

            // Check if we've completed the loop
            if (trackMap.length > 0 && id === trackScanStartId && trackMap.length > 3) {
                log(`âœ“ TRACK LOOP COMPLETE! Mapped ${trackMap.length} pieces`, "win");
                trackScanComplete = true;
                if (cars.length > 0) {
                    cars[0].setSpeed(0);
                    isScanningTrack = false;
                    const btn = document.getElementById('btn-scan-track');
                    if (btn) btn.classList.remove('active');
                }
                return;
            }

            // Set start piece on first detection
            if (trackMap.length === 0) {
                trackScanStartId = id;
            }

            let type = 'STRAIGHT';
            if (name.includes("CURVE")) type = 'CURVE';
            if (name.includes("START") || name.includes("FINISH")) type = 'FINISH';

            const piece = {
                id: id,
                name: name,
                type: type,
                clockwise: false // Will be determined by TRANSITION_UPDATE for curves
            };

            trackMap.push(piece);
            log(`MAPPED: ${piece.name} [${piece.id}] ${piece.type == 'CURVE' ? (piece.clockwise ? '(R)' : '(L)') : ''} (${trackMap.length})`, "info");

            drawMap(trackMap, piece.id);
        }

        function drawMap(map, currentId) {
            if (!mapCanvas) {
                // Create map container in bottom-left
                const container = document.createElement('div');
                container.id = 'map-container';
                container.style.position = 'fixed';
                container.style.bottom = '20px';
                container.style.left = '20px';
                container.style.width = '350px';
                container.style.height = '250px';
                container.style.zIndex = '40';

                const canvas = document.createElement('canvas');
                canvas.width = 350;
                canvas.height = 250;
                container.appendChild(canvas);

                document.body.appendChild(container);
                mapCanvas = canvas;
            }

            const ctx = mapCanvas.getContext('2d');
            ctx.clearRect(0, 0, 350, 250);

            // Start center
            let x = 175, y = 125;
            let dir = 0; // 0: Right, 1: Down, 2: Left, 3: Up
            const SIZE = 20;

            // Enhanced styling
            ctx.strokeStyle = '#00f0ff';
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.shadowBlur = 8;
            ctx.shadowColor = '#00f0ff';

            const pieceCoords = {};

            ctx.beginPath();
            ctx.moveTo(x, y);

            map.forEach((p, idx) => {
                pieceCoords[p.id] = { x, y };

                if (p.type === 'STRAIGHT' || p.type === 'FINISH') {
                    let dx = (dir === 0 ? SIZE : dir === 2 ? -SIZE : 0);
                    let dy = (dir === 1 ? SIZE : dir === 3 ? -SIZE : 0);
                    ctx.lineTo(x + dx, y + dy);
                    x += dx; y += dy;
                }
                else if (p.type === 'CURVE') {
                    // Calculate new direction
                    let newDir;
                    if (p.clockwise) { // Right turn
                        newDir = (dir + 1) % 4;
                    } else { // Left turn
                        newDir = (dir + 3) % 4;
                    }

                    // Calculate endpoint
                    let dx, dy;
                    if (p.clockwise) {
                        if (dir == 0) { dx = SIZE; dy = SIZE; }
                        if (dir == 1) { dx = -SIZE; dy = SIZE; }
                        if (dir == 2) { dx = -SIZE; dy = -SIZE; }
                        if (dir == 3) { dx = SIZE; dy = -SIZE; }
                    } else {
                        if (dir == 0) { dx = SIZE; dy = -SIZE; }
                        if (dir == 1) { dx = SIZE; dy = SIZE; }
                        if (dir == 2) { dx = -SIZE; dy = SIZE; }
                        if (dir == 3) { dx = -SIZE; dy = -SIZE; }
                    }

                    // Control point for smooth curve
                    let cpx = x + (dir == 0 ? SIZE : dir == 2 ? -SIZE : 0);
                    let cpy = y + (dir == 1 ? SIZE : dir == 3 ? -SIZE : 0);

                    ctx.quadraticCurveTo(cpx, cpy, x + dx, y + dy);

                    x += dx; y += dy;
                    dir = newDir;
                }
            });
            ctx.stroke();

            // Draw piece numbers and markers
            ctx.shadowBlur = 0;
            map.forEach((p, idx) => {
                const pos = pieceCoords[p.id];
                if (pos) {
                    // Draw piece number
                    ctx.fillStyle = '#00f0ff';
                    ctx.font = 'bold 10px Orbitron';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(idx + 1, pos.x, pos.y);

                    // Mark finish line
                    if (p.type === 'FINISH') {
                        ctx.strokeStyle = '#ffa600';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(pos.x, pos.y, 8, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                }
            });

            // Draw car positions
            function drawCarMarker(id, color) {
                const pos = pieceCoords[id];
                if (pos) {
                    ctx.fillStyle = color;
                    ctx.shadowBlur = 5;
                    ctx.shadowColor = color;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            }
            cars.forEach(c => drawCarMarker(c.currentPieceId, c.profile.color));
            for (let id in remoteCars) {
                drawCarMarker(remoteCars[id].pieceId, remoteCars[id].color);
            }
        }

    </script>
</body>

</html>